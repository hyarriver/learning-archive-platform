# 技术选型说明

## 一、技术栈概览

### 后端框架：FastAPI ✅

**选择理由**：
- ✅ 高性能：基于 Starlette 和 Pydantic，性能接近 Node.js 和 Go
- ✅ 自动文档：OpenAPI/Swagger 自动生成，开发友好
- ✅ 类型检查：Pydantic 数据验证，减少错误
- ✅ 异步支持：原生 async/await，适合 I/O 密集型任务
- ✅ 学习曲线低：Python 生态，API 设计简洁

**替代方案**：Flask（更传统但性能略低）、Django（功能过重）

---

### 数据库：SQLite ✅

**选择理由**：
- ✅ 零配置：无需单独安装和配置数据库服务
- ✅ 轻量级：单文件数据库，<50 用户场景足够
- ✅ 可靠性：ACID 事务支持，数据安全
- ✅ 易于备份：直接复制 `.db` 文件即可

**适用场景**：
- 单机部署
- 用户量 < 50
- 无高并发需求
- 存储量 < 40GB

**未来扩展**：如用户增长，可迁移到 PostgreSQL（SQLAlchemy ORM 支持）

---

### 爬虫框架：requests + BeautifulSoup ✅

**选择理由**：
- ✅ 简单易用：API 直观，上手快
- ✅ 灵活性：可组合使用，按需扩展
- ✅ 成熟稳定：社区广泛使用，问题易解决

**针对动态内容**：
- Selenium / Playwright（JavaScript 渲染）
- 仅当必要时使用（性能开销大）

**视频字幕**：
- yt-dlp（原 youtube-dl 的改进版）
- 支持主流视频平台（YouTube、B站等）

---

### Markdown转换：pandoc（优先）✅

**选择理由**：
- ✅ 高质量转换：支持复杂 HTML 结构
- ✅ 格式完整：代码块、表格、数学公式
- ✅ 跨平台：Windows/Linux/Mac 支持

**备选方案**：
- html2text（Python 原生，无需外部依赖）
- 作为 fallback 使用

**使用策略**：
1. 优先使用 pandoc（如已安装）
2. Fallback 到 html2text
3. 保留原始 HTML 备份（可选）

---

### 任务调度：APScheduler ✅

**选择理由**：
- ✅ Python 原生：无需系统 cron 配置
- ✅ 灵活调度：支持多种触发方式
- ✅ 持久化：可保存任务状态（可选）
- ✅ 易于测试：可手动触发任务

**替代方案**：
- Cron（系统级，跨平台配置复杂）
- Celery（功能过重，需要 Redis）

---

### 前端：响应式 HTML/CSS/JS（方案A）✅

**选择理由（方案A - 简单版）**：
- ✅ 快速开发：无需构建工具
- ✅ 轻量级：文件小，加载快
- ✅ 易维护：代码直观

**方案B - 现代化（可选）**：
- React/Vue + Vite
- 适合需要复杂交互的场景

**推荐**：先采用方案A，如后续需要复杂交互再迁移

---

## 二、核心依赖说明

### Web 框架层
```
fastapi==0.104.1           # Web框架
uvicorn[standard]==0.24.0  # ASGI服务器（支持HTTP/2、WebSocket）
python-multipart==0.0.6    # 文件上传支持
```

### 数据库层
```
sqlalchemy==2.0.23         # ORM（可选，也可用原生SQL）
```

### 认证层
```
python-jose[cryptography]  # JWT Token生成与验证
passlib[bcrypt]            # 密码加密
```

### HTTP 请求层
```
requests==2.31.0           # 同步HTTP（爬虫主要使用）
aiohttp==3.9.1             # 异步HTTP（可选，性能优化时使用）
```

### 爬虫与解析层
```
beautifulsoup4==4.12.2     # HTML解析
lxml==4.9.3                # 快速XML/HTML解析器（BeautifulSoup后端）
html2text==2020.1.16       # HTML转Markdown（fallback）
yt-dlp==2023.11.16         # 视频字幕提取
```

### Markdown处理层
```
markdown==3.5.1            # Markdown渲染（前端展示）
pymdown-extensions         # Markdown扩展（表格、代码高亮等）
```

### 任务调度层
```
apscheduler==3.10.4        # 任务调度
```

### 工具库
```
python-dotenv==1.0.0       # 环境变量管理
pydantic==2.5.0            # 数据验证（FastAPI已集成）
pydantic-settings==2.1.0   # 配置管理
loguru==0.7.2              # 日志（可选，替代标准logging）
```

---

## 三、关键技术决策

### 3.1 为什么不用 Docker？

**当前阶段**：
- 单机部署，无需容器化
- SQLite 无需独立服务
- 减少部署复杂度

**未来如需**：
- 可随时添加 Dockerfile
- 不影响现有架构

### 3.2 为什么不用 Redis？

**当前场景**：
- 用户量小，无需缓存
- 无分布式任务需求
- SQLite 性能足够

**如需缓存**：
- 可使用内存缓存（Python dict）
- 或文件系统缓存

### 3.3 为什么不用消息队列？

**当前场景**：
- 定时任务简单，APScheduler 足够
- 无异步任务队列需求

**未来扩展**：
- 如采集量大，可引入 Celery + Redis
- 当前保持简单

### 3.4 为什么前端不用框架？

**方案A优势**：
- MVP 阶段，快速验证
- 减少学习成本
- 易于调试

**何时升级**：
- 需要复杂交互（拖拽、实时更新）
- 需要组件复用
- 团队熟悉 React/Vue

---

## 四、性能考虑

### 4.1 数据库查询优化

- ✅ 索引：在 `file_hash`、`source_id`、`status` 上创建索引
- ✅ 分页：文件列表使用 LIMIT/OFFSET
- ✅ 连接池：SQLite 连接复用（默认已优化）

### 4.2 爬虫性能

- ✅ 异步并发：多源并行采集（asyncio/aiohttp）
- ✅ 请求延迟：避免被封（1-2秒间隔）
- ✅ 重试机制：失败自动重试

### 4.3 文件处理

- ✅ 流式处理：大文件分块读取
- ✅ 哈希计算：仅计算新文件
- ✅ 压缩存储：Markdown 文本压缩比高

---

## 五、安全考虑

### 5.1 认证安全

- ✅ 密码加密：bcrypt（不可逆哈希）
- ✅ JWT Token：短期有效（24小时）
- ✅ HTTPS：生产环境必须启用

### 5.2 文件安全

- ✅ 路径验证：防止路径遍历攻击
- ✅ 文件类型检查：限制上传类型
- ✅ 访问控制：仅登录用户可访问

### 5.3 爬虫安全

- ✅ User-Agent：模拟浏览器
- ✅ 请求频率：避免对目标网站造成压力
- ✅ 错误处理：不暴露内部信息

---

## 六、扩展性路径

### 6.1 数据库迁移路径

```
SQLite (当前)
    ↓ (如用户量增长)
PostgreSQL
    ↓ (如需要分布式)
MySQL Cluster
```

### 6.2 存储迁移路径

```
本地文件系统 (当前)
    ↓ (如存储空间不足)
云存储 (OSS/S3)
    ↓ (如需要CDN)
对象存储 + CDN
```

### 6.3 前端升级路径

```
HTML/CSS/JS (当前)
    ↓ (如需要复杂交互)
React/Vue
    ↓ (如需要服务端渲染)
Next.js/Nuxt.js
```

---

## 七、依赖版本锁定策略

### 为什么锁定版本？

- ✅ 避免自动更新导致破坏性变更
- ✅ 保证团队开发环境一致
- ✅ 生产环境稳定性

### 更新策略

- 定期检查安全更新（每月一次）
- 测试后再升级（小版本可快速升级，大版本需谨慎）
- 记录升级日志

---

## 八、总结

### 技术选型原则

1. **优先成熟方案**：避免使用过于前沿的技术
2. **保持轻量**：不引入不必要的中间件
3. **易于维护**：选择团队熟悉的技术
4. **可扩展性**：预留升级路径，但不提前优化

### 核心优势

- ✅ 技术栈成熟稳定
- ✅ 学习成本低
- ✅ 部署简单
- ✅ 性能足够（<50用户场景）
